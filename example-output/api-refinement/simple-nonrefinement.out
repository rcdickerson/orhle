
*******************************************
****               ORHLE               ****
****     The Oracular RHLE Verifier    ****
*******************************************

:: Executions
  refinement (forall)
  original (exists)

:: Universal Programs
[ SSeq
    [ SCall "refinement!refinedRand" [] [ refinement ! x ]
    , SAsgn refinement ! retVal (AVar refinement ! x)
    ]
]

:: Existential Programs
[ SSeq
    [ SCall "original!originalRand" [] [ original ! x ]
    , SAsgn original ! retVal (AVar original ! x)
    ]
]

:: Universal Specifications
fromList [("refinement!refinedRand",Spec {spec_params = [], spec_choiceVars = [], spec_preCondition = ATrue, spec_postCondition = And [Gte (Var ret!) (Num 0),Lt (Var ret!) (Num 25)]})]

:: Existential Specifications
fromList [("original!originalRand",Spec {spec_params = [], spec_choiceVars = [original!n], spec_preCondition = And [Gte (Var original!n) (Num 0),Lt (Var original!n) (Num 20)], spec_postCondition = Eq (Var ret!) (Var original!n)})]

:: Precondition
ATrue

:: Postcondition
Eq (Var original ! x) (Var refinement ! x)

[send->] (set-option :print-success true )
[<-recv] success
[send->] (set-option :produce-models true )
[<-recv] success
[send->] (declare-const refinement!x Int)
[<-recv] success
[send->] (assert (not (=> true
         (and true
              (=> (and (>= refinement!x 0) (< refinement!x 25))
                  (exists ((original!n Int))
                     (and (and (>= original!n 0) (< original!n 20))
                          (exists ((original!x!1 Int))
                             (= original!x!1 original!n))
                          (forall ((original!x!1 Int))
                             (=> (= original!x!1 original!n)
                                 (= original!x!1 refinement!x))))))))) )
[<-recv] success
[send->] (check-sat )
[<-recv] sat
[send->] (get-model )
[<-recv] (model (define-fun refinement!x () Int 20 ) )
Failure:
  (model (define-fun refinement!x () Int 20 ) )

real	0m0.200s
user	0m0.184s
sys	0m0.012s
