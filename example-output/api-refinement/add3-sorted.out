Replacements: fromList [(original!shuffled_0,original!shuffled_0!1),(original!shuffled_1,original!shuffled_1!1),(original!shuffled_2,original!shuffled_2!1)]

*******************************************
****               ORHLE               ****
****     The Oracular RHLE Verifier    ****
*******************************************

:: Executions
  refinement (forall)
  original (exists)

Universal Programs:
[ SSeq
    [ SCall
        SFun
          { fName = refinement ! sort
          , fParams =
              [ refinement ! list_0 , refinement ! list_1 , refinement ! list_2 ]
          }
        [ refinement ! sorted_0
        , refinement ! sorted_1
        , refinement ! sorted_2
        ]
    , SAsgn refinement !
        ret_0 (AAdd (AVar refinement ! sorted_0) (ALit 3))
    , SAsgn refinement !
        ret_1 (AAdd (AVar refinement ! sorted_1) (ALit 3))
    , SAsgn refinement !
        ret_2 (AAdd (AVar refinement ! sorted_2) (ALit 3))
    ]
]

Existential Programs:
[ SSeq
    [ SCall
        SFun
          { fName = original ! shuffle
          , fParams =
              [ original ! list_0 , original ! list_1 , original ! list_2 ]
          }
        [ original ! shuffled_0
        , original ! shuffled_1
        , original ! shuffled_2
        ]
    , SAsgn original !
        ret_0 (AAdd (AVar original ! shuffled_0) (ALit 3))
    , SAsgn original !
        ret_1 (AAdd (AVar original ! shuffled_1) (ALit 3))
    , SAsgn original !
        ret_2 (AAdd (AVar original ! shuffled_2) (ALit 3))
    ]
]

Universal Specifications:
fromList [(refinement!sort,Spec {params = [refinement!list], choiceVars = [], preCondition = true, postCondition = (and (<= ret!0 ret!1) (<= ret!1 ret!2) (or (and (= ret!0 refinement!list_0) (= ret!1 refinement!list_1) (= ret!2 refinement!list_2)) (and (= ret!0 refinement!list_0) (= ret!1 refinement!list_2) (= ret!2 refinement!list_1)) (and (= ret!0 refinement!list_1) (= ret!1 refinement!list_0) (= ret!2 refinement!list_2)) (and (= ret!0 refinement!list_1) (= ret!1 refinement!list_2) (= ret!2 refinement!list_0)) (and (= ret!0 refinement!list_2) (= ret!1 refinement!list_0) (= ret!2 refinement!list_1)) (and (= ret!0 refinement!list_2) (= ret!1 refinement!list_1) (= ret!2 refinement!list_0))))})]

Existential Specifications:
fromList [(original!shuffle,Spec {params = [original!list], choiceVars = [(original!n0 int),(original!n1 int),(original!n2 int)], preCondition = (or (and (= original!n0 original!list_0) (= original!n1 original!list_1) (= original!n2 original!list_2)) (and (= original!n0 original!list_0) (= original!n1 original!list_2) (= original!n2 original!list_1)) (and (= original!n0 original!list_1) (= original!n1 original!list_0) (= original!n2 original!list_2)) (and (= original!n0 original!list_1) (= original!n1 original!list_2) (= original!n2 original!list_0)) (and (= original!n0 original!list_2) (= original!n1 original!list_0) (= original!n2 original!list_1)) (and (= original!n0 original!list_2) (= original!n1 original!list_1) (= original!n2 original!list_0))), postCondition = (and (= ret!0 original!n0) (= ret!1 original!n1) (= ret!2 original!n2))})]

Precondition:
  (and (= original!list_0 refinement!list_0) (= original!list_1 refinement!list_1) (= original!list_2 refinement!list_2))

Postcondition:
  (and (= original!ret_0 refinement!ret_0) (= original!ret_1 refinement!ret_1) (= original!ret_2 refinement!ret_2))

[send->] (set-option :print-success true )
[<-recv] success
[send->] (set-option :produce-models true )
[<-recv] success
[send->] (declare-const original!list_0 Int)
[<-recv] success
[send->] (declare-const original!list_1 Int)
[<-recv] success
[send->] (declare-const original!list_2 Int)
[<-recv] success
[send->] (declare-const refinement!list_0 Int)
[<-recv] success
[send->] (declare-const refinement!list_1 Int)
[<-recv] success
[send->] (declare-const refinement!list_2 Int)
[<-recv] success
[send->] (declare-const refinement!sorted_0 Int)
[<-recv] success
[send->] (declare-const refinement!sorted_1 Int)
[<-recv] success
[send->] (declare-const refinement!sorted_2 Int)
[<-recv] success
[send->] (assert (not (=> (and (= original!list_0 refinement!list_0)
              (= original!list_1 refinement!list_1)
              (= original!list_2 refinement!list_2))
         (and true
              (=> (and (<= refinement!sorted_0 refinement!sorted_1)
                       (<= refinement!sorted_1 refinement!sorted_2)
                       (or (and (= refinement!sorted_0 refinement!list_0)
                                (= refinement!sorted_1 refinement!list_1)
                                (= refinement!sorted_2 refinement!list_2))
                           (and (= refinement!sorted_0 refinement!list_0)
                                (= refinement!sorted_1 refinement!list_2)
                                (= refinement!sorted_2 refinement!list_1))
                           (and (= refinement!sorted_0 refinement!list_1)
                                (= refinement!sorted_1 refinement!list_0)
                                (= refinement!sorted_2 refinement!list_2))
                           (and (= refinement!sorted_0 refinement!list_1)
                                (= refinement!sorted_1 refinement!list_2)
                                (= refinement!sorted_2 refinement!list_0))
                           (and (= refinement!sorted_0 refinement!list_2)
                                (= refinement!sorted_1 refinement!list_0)
                                (= refinement!sorted_2 refinement!list_1))
                           (and (= refinement!sorted_0 refinement!list_2)
                                (= refinement!sorted_1 refinement!list_1)
                                (= refinement!sorted_2 refinement!list_0))))
                  (exists ((original!n0 Int) (original!n1 Int) (original!n2 Int))
                     (and (or (and (= original!n0 original!list_0)
                                   (= original!n1 original!list_1) (= original!n2 original!list_2))
                              (and (= original!n0 original!list_0)
                                   (= original!n1 original!list_2) (= original!n2 original!list_1))
                              (and (= original!n0 original!list_1)
                                   (= original!n1 original!list_0) (= original!n2 original!list_2))
                              (and (= original!n0 original!list_1)
                                   (= original!n1 original!list_2) (= original!n2 original!list_0))
                              (and (= original!n0 original!list_2)
                                   (= original!n1 original!list_0) (= original!n2 original!list_1))
                              (and (= original!n0 original!list_2)
                                   (= original!n1 original!list_1) (= original!n2 original!list_0)))
                          (exists ((original!shuffled_0!1 Int) (original!shuffled_1!1 Int)
                                   (original!shuffled_2!1 Int))
                             (and (= original!shuffled_0!1 original!n0)
                                  (= original!shuffled_1!1 original!n1)
                                  (= original!shuffled_2!1 original!n2)))
                          (forall ((original!shuffled_0!1 Int) (original!shuffled_1!1 Int)
                                   (original!shuffled_2!1 Int))
                             (=> (and (= original!shuffled_0!1 original!n0)
                                      (= original!shuffled_1!1 original!n1)
                                      (= original!shuffled_2!1 original!n2))
                                 (and (= (+ original!shuffled_0!1 3) (+ refinement!sorted_0 3))
                                      (= (+ original!shuffled_1!1 3) (+ refinement!sorted_1 3))
                                      (= (+ original!shuffled_2!1 3)
                                         (+ refinement!sorted_2 3))))))))))) )
[<-recv] success
[send->] (check-sat )
[<-recv] unsat
Valid.

real	0m0.101s
user	0m0.084s
sys	0m0.054s
