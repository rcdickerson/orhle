// Dropping a sort guarantee from an API is OK when
// the caller performs some operation that doesn't
// care about list order.

expected: valid;

forall: p[refinement];
exists: p[original];

pre: (or
       (and (= p!original!list_0 p!refinement!list_0)
            (= p!original!list_1 p!refinement!list_1)
            (= p!original!list_2 p!refinement!list_2))
       (and (= p!original!list_0 p!refinement!list_0)
            (= p!original!list_1 p!refinement!list_2)
            (= p!original!list_2 p!refinement!list_1))
       (and (= p!original!list_0 p!refinement!list_1)
            (= p!original!list_1 p!refinement!list_0)
            (= p!original!list_2 p!refinement!list_2))
       (and (= p!original!list_0 p!refinement!list_1)
            (= p!original!list_1 p!refinement!list_2)
            (= p!original!list_2 p!refinement!list_0))
       (and (= p!original!list_0 p!refinement!list_2)
            (= p!original!list_1 p!refinement!list_0)
            (= p!original!list_2 p!refinement!list_1))
       (and (= p!original!list_0 p!refinement!list_2)
            (= p!original!list_1 p!refinement!list_1)
            (= p!original!list_2 p!refinement!list_0)));
post: (= p!original!sum p!refinement!sum);

// The original API call guarantees an ordered list.
// The refinement makes no guarantees. This is OK
// because the sum of the list is the same regardless
// of ordering.

aspecs:
  getThreeThings() {
    pre: true;
    post: true;
  }

especs:
  getThreeThings() {
      templateVars: n0, n1, n2;
      pre: (and (<= n0 n1) (<= n1 n2));
      post (and (= ret!0 n0) (= ret!1 n1) (= ret!2 n2));
  }

prog p():
   list[3] := call getThreeThings();
   sum := list_0 + list_1 + list_2;
endp