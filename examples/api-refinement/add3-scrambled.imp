forall: refinement;
exists: original;

pre:  (and
        (= original!list_0 refinement!list_0)
        (= original!list_1 refinement!list_1)
        (= original!list_2 refinement!list_2));
post: (and
        (= original!ret_0 refinement!ret_0)
        (= original!ret_1 refinement!ret_1)
        (= original!ret_2 refinement!ret_2));

expected: invalid;

// The original program sorts the list then adds three
// to each value.
prog original(list):
  sorted[3] := call sort(list)
      @templateVars { n0, n1, n2 }
      @pre { (and (<= n0 n1)
                  (<= n1 n2)
                  (or (and (= n0 list_0)
                           (= n1 list_1)
                           (= n2 list_2))
                      (and (= n0 list_0)
                           (= n1 list_2)
                           (= n2 list_1))
                      (and (= n0 list_1)
                           (= n1 list_0)
                           (= n2 list_2))
                      (and (= n0 list_1)
                           (= n1 list_2)
                           (= n2 list_0))
                      (and (= n0 list_2)
                           (= n1 list_0)
                           (= n2 list_1))
                      (and (= n0 list_2)
                           (= n1 list_1)
                           (= n2 list_0)))) }
      @post { (and (= sorted_0 n0)
                   (= sorted_1 n1)
                   (= sorted_2 n2)) };
  ret_0 := sorted_0 + 3;
  ret_1 := sorted_1 + 3;
  ret_2 := sorted_2 + 3;
endp

// The refinement program scrambles the list to some
// arbitrary permutation then adds three to each value.
prog refinement(list):
  scrambled[3] := call sort(list)
      @post { (or (and (= scrambled_0 list_0)
                       (= scrambled_1 list_1)
                       (= scrambled_2 list_2))
                   (and (= scrambled_0 list_0)
                        (= scrambled_1 list_2)
                        (= scrambled_2 list_1))
                   (and (= scrambled_0 list_1)
                        (= scrambled_1 list_0)
                        (= scrambled_2 list_2))
                   (and (= scrambled_0 list_1)
                        (= scrambled_1 list_2)
                        (= scrambled_2 list_0))
                   (and (= scrambled_0 list_2)
                        (= scrambled_1 list_0)
                        (= scrambled_2 list_1))
                   (and (= scrambled_0 list_2)
                        (= scrambled_1 list_1)
                        (= scrambled_2 list_0))) };
  ret_0 := scrambled_0 + 3;
  ret_1 := scrambled_1 + 3;
  ret_2 := scrambled_2 + 3;
endp
