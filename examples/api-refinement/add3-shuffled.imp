expected: invalid;

forall: refinement;
exists: original;

pre:  (and
        (= original!list_0 refinement!list_0)
        (= original!list_1 refinement!list_1)
        (= original!list_2 refinement!list_2));
post: (and
        (= original!ret_0 refinement!ret_0)
        (= original!ret_1 refinement!ret_1)
        (= original!ret_2 refinement!ret_2));

aspecs:
  shuffle(list) {
    post: (or (and (= shuffled_0 list_0)
                   (= shuffled_1 list_1)
                   (= shuffled_2 list_2))
               (and (= shuffled_0 list_0)
                    (= shuffled_1 list_2)
                    (= shuffled_2 list_1))
               (and (= shuffled_0 list_1)
                    (= shuffled_1 list_0)
                    (= shuffled_2 list_2))
               (and (= shuffled_0 list_1)
                    (= shuffled_1 list_2)
                    (= shuffled_2 list_0))
               (and (= shuffled_0 list_2)
                    (= shuffled_1 list_0)
                    (= shuffled_2 list_1))
               (and (= shuffled_0 list_2)
                    (= shuffled_1 list_1)
                    (= shuffled_2 list_0)));
  }

especs:
  sort(list) {
    templateVars: n0, n1, n2;
    pre: (and (<= n0 n1)
              (<= n1 n2)
              (or (and (= n0 list_0)
                       (= n1 list_1)
                       (= n2 list_2))
                  (and (= n0 list_0)
                       (= n1 list_2)
                       (= n2 list_1))
                  (and (= n0 list_1)
                       (= n1 list_0)
                       (= n2 list_2))
                  (and (= n0 list_1)
                       (= n1 list_2)
                       (= n2 list_0))
                  (and (= n0 list_2)
                       (= n1 list_0)
                       (= n2 list_1))
                  (and (= n0 list_2)
                       (= n1 list_1)
                       (= n2 list_0))));
    post: (and (= sorted_0 n0)
               (= sorted_1 n1)
               (= sorted_2 n2));
  }

// The original program sorts the list then adds three
// to each value.
prog original(list):
  sorted[3] := call sort(list);
  ret_0 := sorted_0 + 3;
  ret_1 := sorted_1 + 3;
  ret_2 := sorted_2 + 3;
endp

// The refinement program shuffles the list to some
// arbitrary permutation then adds three to each value.
prog refinement(list):
  shuffled[3] := call shuffle(list);
  ret_0 := shuffled_0 + 3;
  ret_1 := shuffled_1 + 3;
  ret_2 := shuffled_2 + 3;
endp
